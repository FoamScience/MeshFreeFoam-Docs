<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MeshFreeFoam API Docs â€“ openfoam</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/</link><description>Recent content in openfoam on MeshFreeFoam API Docs</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 27 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Runtime selection mechanism for `MeshFreeFoam`</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</guid><description>
&lt;p>In short, I&amp;rsquo;ll stick with OpenFOAM&amp;rsquo;s way of doing things when it comes:&lt;/p>
&lt;ul>
&lt;li>RunTime Selection of models&lt;/li>
&lt;li>The plugin system (Function Objects)&lt;/li>
&lt;/ul>
&lt;h2 id="issue-01-dependency-on-the-openfoam-version">Issue 01: Dependency on the OpenFOAM version&lt;/h2>
&lt;p>I have decided to run with the master branch from &lt;a href="https://develop.openfoam.com/Development/openfoam">OpenCFD&amp;rsquo;s OpenFOAM&lt;/a> and the very first I encounter is that the RunTime selection mechanism has changed somewhen between &lt;code>v2012&lt;/code> and &lt;code>v2306&lt;/code>. Not cool.&lt;/p>
&lt;p>So, my solution is to have my own macros for runtime selection but, in the end, they need to be compatible with the version I compile my toolkit with. This is exactly why dependency management will be a challenge on its own.&lt;/p>
&lt;h2 id="issue-02-going-too-far-with-ood-and-effects-on-gpu-optimization">Issue 02: Going too far with OOD and effects on GPU optimization&lt;/h2>
&lt;p>When I look at all public projects which are optimizing for GPU offloading (Here is an &lt;a href="https://github.com/exapde/Exasim">example&lt;/a>) there seems to be no tolerance for virtual methods. Actually, NVIDIA explicitly advises to move away from object oriented design.&lt;/p>
&lt;p>While this is not an option for as, the plan is to have two modes:&lt;/p>
&lt;ul>
&lt;li>One mode employing the standard way of doing things in OpenFOAM in terms of RTS&lt;/li>
&lt;li>A second mode which either leverages &lt;code>dynamicMesh&lt;/code> or some kind of &lt;a href="https://github.com/jmmartinez/easy-just-in-time">&lt;code>JIT compiler&lt;/code>&lt;/a> to generate de-virtualized code at runtime.&lt;/li>
&lt;/ul></description></item><item><title>Blog: Introducing unit tests with foamUT</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</guid><description>
&lt;p>Well, there are three clear objects for unit testing:&lt;/p>
&lt;ul>
&lt;li>Making sure new code does not break older functionality&lt;/li>
&lt;li>Making sure new functionality works as expected&lt;/li>
&lt;li>Making sure important dependency APIs have not changed without us noticing&lt;/li>
&lt;/ul>
&lt;p>To this end, I originally crafted the &lt;a href="https://github.com/FoamScience/foamUT">foamUT&lt;/a> toolkit to unit-test OpenFOAM code in a streamlined way. All that is needed is to write by-library tests and supply the appropriate &lt;code>Make/files&lt;/code> and &lt;code>Make/options&lt;/code> files to compile them. Example tests are provided in the &lt;a href="https://github.com/FoamScience/MeshFreeFoam/tree/master/tests">MeshFreeFoam&lt;/a> repository.&lt;/p>
&lt;p>Unit tests marvelously demonstrate usage of different code entities so I thought we would add them to the documentation website. Head to &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/tests">tests&lt;/a> to browse all unit tests and see their latest states.&lt;/p>
&lt;p>Currently, this feature relies on parsing Catch2 XML reports and I doubt this will change. Of course, at this point,&lt;br />
I&amp;rsquo;m only supporting simple test case reports. I&amp;rsquo;ll expand as I go.&lt;/p></description></item><item><title>Blog: Optimization notes: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</guid><description>
&lt;h2 id="kdtree-and-radius-based-searches">KdTree and radius-based searches&lt;/h2>
&lt;p>After sweeping the existing C++ libraries capable of doing k-nearest neighbor (KNN) search with unsorted radius queries, I have reached the conclusion of using &lt;a href="https://github.com/jlblancoc/nanoflann">nanoflann&lt;/a> as a backend for such searches.&lt;/p>
&lt;p>Their API is nice and easy to use but with one specific caveat: The dynamic &lt;code>KdTree&lt;/code> is not trivial to use. After putting up some unit tests to the KdTree wrapper, I quickly discovered that changing the list of point positions we perform searches against is not fun. My current solution is to hash the current content of the list and check it again on each KNN search!&lt;/p>
&lt;p>If the list of points has been radically changed, the KdTree index will be invalid; so we need to reset it. But, if the list is only being appended to (no changes to old elements), the new points are added to the index.&lt;/p>
&lt;p>At this point, I have mainly three unanswered question:&lt;/p>
&lt;ul>
&lt;li>How efficient is to hash the point list?&lt;/li>
&lt;li>How efficient OpenFOAM&amp;rsquo;s implementation of Jenkins hasher is?&lt;/li>
&lt;li>How efficient is to reset the KdTree index (compared to remove all points and add add the new ones)?&lt;/li>
&lt;/ul></description></item><item><title>Blog: Lazy Evaluation: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/27/lazy-evaluation-part-1/</link><pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/27/lazy-evaluation-part-1/</guid><description>
&lt;div style="position:relative;padding-bottom:56.25%;">
&lt;iframe style="width:100%;height:100%;position:absolute;left:0px;top:0px;" frameborder="0" width="100%" height="100%" allowfullscreen="" allow="autoplay" src="./LazyEvaluationAnimation.html">
&lt;/iframe>
&lt;/div>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>I used to think of OpenFOAM&amp;rsquo;s &lt;code>tmp&lt;/code> class template as a memory management thing. After having some suspicions, I had a discussion &lt;a href="https://www.linkedin.com/in/holger-marschall-62175683/">@holger&lt;/a> on the details of using &lt;code>tmp&lt;/code> to get things out of function scope. As we&amp;rsquo;ve skimmed through the code, we start to think of it as a lazy evaluation thing. The main reason was that we would encounter operations of this signature &lt;code>tmp&amp;lt;T&amp;gt; BINARY_FUNCTION(T vf1, T vf2)&lt;/code> more and more.&lt;/p>
&lt;p>So, I went and added Info statements to the fields constructors, and discovered that&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#333">=&lt;/span> b &lt;span style="color:#333">+&lt;/span> c &lt;span style="color:#333">+&lt;/span> d; &lt;span style="color:#888">// as fields
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>would not construct two (from eagerly-doing the plus operations) but just one temporary object is created. This tricked me into thinking that those operations are done lazily. The same memory is reused for both operations, which does save up on memory usage, but memory reads/writes still get carried out at the same spots as in traditional eager evaluation.&lt;/p>
&lt;p>It seems that &lt;code>tmp&lt;/code> was originally designed to optimize memory handling which has improved a lot in newer C++ standards. A recent C++ compiler performs move construction/assignment on return statements instead of copying which makes &lt;code>tmp&lt;/code> redundant:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Assume Field&amp;lt;scalar&amp;gt; has a move constructor and assignment operator
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>scalarField &lt;span style="color:#06b;font-weight:bold">add&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> scalarField&lt;span style="color:#333">&amp;amp;&lt;/span> a, &lt;span style="color:#080;font-weight:bold">const&lt;/span> scalarField&lt;span style="color:#333">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> a &lt;span style="color:#333">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scalarField &lt;span style="color:#06b;font-weight:bold">c&lt;/span>(add(a,b)); &lt;span style="color:#888">// This will move-construct c from result of a+b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Older compilers will do a copy; that&amp;#39;s why most functions return a tmp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, &lt;code>tmp&lt;/code> has nothing to do with lazy evaluation, but computing linear combinations of stuff is all we do in CFD, and MeshFreeFoam is no different. Being able to compute ${\bf x_1} + a {\bf x_2}$ efficiently is crucial. Here is the landscape of how efficient we can be:&lt;/p>
&lt;ul>
&lt;li>Regular C++: compute $a {\bf x_2}$ then add it to ${\bf x_1}$. Which too wasteful (at least memory-wise).&lt;/li>
&lt;li>With OpenFOAM&amp;rsquo;s &lt;code>tmp&lt;/code>: saves on new memory allocation on addition but is still wasteful when it comes to CPU cycles.&lt;/li>
&lt;/ul>
&lt;p>Despite being a .Net language, F# (and most of other functional languages) nailed on-demand computation. In an attempt to bring that level of functionality to my PhD project, I investigate how would lazy evaluation be implemented for OpenFOAM-based code.&lt;/p>
&lt;h2 id="lazy-evaluation-with-expression-templates">Lazy evaluation with expression templates&lt;/h2>
&lt;p>The first candidate was expression templates. I have heard of this concept countless times before. I even had my own my matrix implementation that allowed to perform operations only on a subset of rows/column. While that is not so useful now, being familiar with the concept helps. Also, with C++17 and newer standards, the implementation of expression templates has become much easier compared to five or six years back.&lt;/p>
&lt;p>One inherent drawback of a rigorous implementation of expression templates is that they can add some considerable complexity to the code in regard of ordering computations:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Assume &amp;lt;&amp;lt;, + and * are implemented with expression templates
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>a &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> b &lt;span style="color:#333">+&lt;/span> c; &lt;span style="color:#888">// using &amp;lt;&amp;lt; to denote that this is not an assignment; take it as a mere labeling operation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// a not used, so, let&amp;#39;s not compute it yet
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>b &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>; &lt;span style="color:#888">// now this is an assignment
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>d &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>; &lt;span style="color:#888">// Which values of b were used here? b = 1; but was that intended?
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That said, the performance benefit of implementing expression templates is enormous. It&amp;rsquo;s at least 50% faster that eager evaluation for &lt;a href="https://github.com/FoamScience/Eager-TemplateExpr-Views-OpenFOAM/blob/80c59112d5660cd24630e4c57c6f7648c8a0b8c7/expressionTemplatesVsViewsTests.C#L30">few operations&lt;/a> (addition, multiplication, subtraction and division of scalar arrays).&lt;/p>
&lt;p>Thus, the next best thing, is a partial expression system which evaluates on assignment to avoid the confusion. Even then, I will have to maintain the whole system while keeping it compatible with OpenFOAM&amp;rsquo;s API. Instead, I started to look at the ranges from C++20 standard library.&lt;/p>
&lt;h2 id="lazy-evaluation-with-views">Lazy evaluation with views&lt;/h2>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Warning&lt;/h4>
NVIDIA&amp;rsquo;s HPC c++ compilers at the moment support only C++17; &lt;a href="https://developer.nvidia.com/blog/accelerating-standard-c-with-gpus-using-stdpar/">using stdpar&lt;/a> will prove difficult if decided to use views. So, for now, it&amp;rsquo;s either to optimize for CPU; &lt;strong>or&lt;/strong> use the GPU. We can&amp;rsquo;t do both as working comfortably with views requires C++23.
&lt;/div>
&lt;p>In particular, C++20 introduces &lt;code>views&lt;/code> which are special kinds of ranges which do not own their data. Think of them as views into the CFD fields. These were perfect for other purposes too, for example, implementation of fit-in-L2-cache subdomains for MeshFreeFoam.&lt;/p>
&lt;p>The biggest problem with views is the thin compiler support. For example, to use &lt;code>zip_transform&lt;/code> which allows to do operations on multiple views at one (eg. binary functions), we have to using at least GCC 13 and link against C++23.&lt;/p>
&lt;p>The performance benefits are very close to what expression templates provide; at much lost maintainability cost; but the uncertainty around them is much higher.&lt;/p>
&lt;p>Thus, building a system on top of views is probably not a good idea when it comes to API stability. But there is always the &lt;a href="https://github.com/ericniebler/range-v3">ranges-v3&lt;/a> library which will hopefully cover anything that the standard libraries might miss. My only concern is that I will not have enough time to wait for standard updates; if anything is missing in c++23 standard library, I will have to switch to &lt;code>ranges-v3&lt;/code> for quite some time or ditch the idea.&lt;/p>
&lt;h2 id="the-benchmarks">The benchmarks&lt;/h2>
&lt;p>You can take a look at the benchmark results at &lt;a href="https://github.com/FoamScience/Eager-TemplateExpr-Views-OpenFOAM">this dedicated repository&lt;/a> which reflect what is shown in the animation above (&lt;code>m&lt;/code>, &lt;code>rho&lt;/code>, &amp;hellip;, etc are all scalar fields). The CI workflows there perform the benchmarks on Github machines (which are not the fastest).&lt;/p>
&lt;p>The correctness and performance of the testing code are recorded by &lt;a href="https://github.com/FoamScience/foamUT">foamUT&lt;/a>; my unit-testing framework for OpenFOAM code (hence MeshFreeFoam too).&lt;/p>
&lt;p>For the sake of exploring the effects of template expressions, I stole and used a &lt;a href="https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/">trivial implementation&lt;/a>:&lt;/p>
&lt;div class="td-card card border me-4">
&lt;div class="card-header bg-white">
Template expression for binary operations on containers in C++
&lt;/div>
&lt;div class="card-body code p-0 m-0">
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-CPP" data-lang="CPP">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">template&lt;/span>&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">T&lt;/span>, &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">U&lt;/span>, &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Callable&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">BinaryContainerExpression&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">template&lt;/span>&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Func&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BinaryContainerExpression(&lt;span style="color:#080;font-weight:bold">const&lt;/span> T&lt;span style="color:#333">&amp;amp;&lt;/span> _left, &lt;span style="color:#080;font-weight:bold">const&lt;/span> U&lt;span style="color:#333">&amp;amp;&lt;/span> _right, Func&lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> _callable) &lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_{&lt;span style="color:#333">&amp;amp;&lt;/span>_left},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_{&lt;span style="color:#333">&amp;amp;&lt;/span>_right},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callable_{std&lt;span style="color:#333">::&lt;/span>forward&lt;span style="color:#333">&amp;lt;&lt;/span>Func&lt;span style="color:#333">&amp;gt;&lt;/span>(_callable)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(_left.size() &lt;span style="color:#333">==&lt;/span> _right.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">auto&lt;/span> &lt;span style="color:#080;font-weight:bold">operator&lt;/span>[](size_t index) &lt;span style="color:#080;font-weight:bold">const&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#06b;font-weight:bold">callable_&lt;/span>((&lt;span style="color:#333">*&lt;/span>left_)[index], (&lt;span style="color:#333">*&lt;/span>right_)[index]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t &lt;span style="color:#06b;font-weight:bold">size&lt;/span>() &lt;span style="color:#080;font-weight:bold">const&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> left_&lt;span style="color:#333">-&amp;gt;&lt;/span>size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> T&lt;span style="color:#333">*&lt;/span> left_&lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> U&lt;span style="color:#333">*&lt;/span> right_&lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Callable callable_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;div class="card-footer">
Not suitable for production code. I&amp;rsquo;m sure I can add syntactic sugar, but that&amp;rsquo;s not the point.&lt;/div>
&lt;/div>
&lt;p>It&amp;rsquo;s worth noting that on &lt;a href="">Github machines&lt;/a> the execution time of lazy evaluations is a third of that of eager evaluations; while on my local machine, it&amp;rsquo;s around 50%. For the recorded, the test machine has the following properties:&lt;/p>
&lt;pre tabindex="0">&lt;code>System: Kernel: 5.15.0-10078* x86_64 bits: 64 compiler: N/A Desktop: Gnome 3.36.9
Distro: Ubuntu 20.04.6 LTS (Focal Fossa)
CPU: Topology: 8-Core model: AMD Ryzen 7 5800H with Radeon Graphics bits: 64 type: MT MCP arch: Zen 3 L2 cache: 4096 KiB
flags: avx avx2 lm nx pae sse sse2 sse3 sse4_1 sse4_2 sse4a ssse3 svm bogomips: 102207
Speed: 1254 MHz min/max: 1200/3200 MHz Core speeds (MHz): 1: 1275 2: 1191 3: 1139 4: 1227 5: 1134 6: 1135 7: 1297
8: 1296 9: 1135 10: 1135 11: 1135 12: 1133 13: 1286 14: 1171 15: 1517 16: 1161
&lt;/code>&lt;/pre>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>If GPU acceleration is not important, &lt;code>Views&lt;/code> it is. This idea might fail horribly though, as everything else.&lt;/p></description></item></channel></rss>