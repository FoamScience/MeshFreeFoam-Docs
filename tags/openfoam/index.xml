<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MeshFreeFoam API Docs â€“ openfoam</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/</link><description>Recent content in openfoam on MeshFreeFoam API Docs</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 29 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Runtime selection mechanism for `MeshFreeFoam`</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</guid><description>
&lt;p>In short, I&amp;rsquo;ll stick with OpenFOAM&amp;rsquo;s way of doing things when it comes:&lt;/p>
&lt;ul>
&lt;li>RunTime Selection of models&lt;/li>
&lt;li>The plugin system (Function Objects)&lt;/li>
&lt;/ul>
&lt;h2 id="issue-01-dependency-on-the-openfoam-version">Issue 01: Dependency on the OpenFOAM version&lt;/h2>
&lt;p>I have decided to run with the master branch from &lt;a href="https://develop.openfoam.com/Development/openfoam">OpenCFD&amp;rsquo;s OpenFOAM&lt;/a> and the very first I encounter is that the RunTime selection mechanism has changed somewhen between &lt;code>v2012&lt;/code> and &lt;code>v2306&lt;/code>. Not cool.&lt;/p>
&lt;p>So, my solution is to have my own macros for runtime selection but, in the end, they need to be compatible with the version I compile my toolkit with. This is exactly why dependency management will be a challenge on its own.&lt;/p>
&lt;h2 id="issue-02-going-too-far-with-ood-and-effects-on-gpu-optimization">Issue 02: Going too far with OOD and effects on GPU optimization&lt;/h2>
&lt;p>When I look at all public projects which are optimizing for GPU offloading (Here is an &lt;a href="https://github.com/exapde/Exasim">example&lt;/a>) there seems to be no tolerance for virtual methods. Actually, NVIDIA explicitly advises to move away from object oriented design.&lt;/p>
&lt;p>While this is not an option for as, the plan is to have two modes:&lt;/p>
&lt;ul>
&lt;li>One mode employing the standard way of doing things in OpenFOAM in terms of RTS&lt;/li>
&lt;li>A second mode which either leverages &lt;code>dynamicMesh&lt;/code> or some kind of &lt;a href="https://github.com/jmmartinez/easy-just-in-time">&lt;code>JIT compiler&lt;/code>&lt;/a> to generate de-virtualized code at runtime.&lt;/li>
&lt;/ul></description></item><item><title>Blog: Introducing unit tests with foamUT</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</guid><description>
&lt;p>Well, there are three clear objects for unit testing:&lt;/p>
&lt;ul>
&lt;li>Making sure new code does not break older functionality&lt;/li>
&lt;li>Making sure new functionality works as expected&lt;/li>
&lt;li>Making sure important dependency APIs have not changed without us noticing&lt;/li>
&lt;/ul>
&lt;p>To this end, I originally crafted the &lt;a href="https://github.com/FoamScience/foamUT">foamUT&lt;/a> toolkit to unit-test OpenFOAM code in a streamlined way. All that is needed is to write by-library tests and supply the appropriate &lt;code>Make/files&lt;/code> and &lt;code>Make/options&lt;/code> files to compile them. Example tests are provided in the &lt;a href="https://github.com/FoamScience/MeshFreeFoam/tree/master/tests">MeshFreeFoam&lt;/a> repository.&lt;/p>
&lt;p>Unit tests marvelously demonstrate usage of different code entities so I thought we would add them to the documentation website. Head to &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/tests">tests&lt;/a> to browse all unit tests and see their latest states.&lt;/p>
&lt;p>Currently, this feature relies on parsing Catch2 XML reports and I doubt this will change. Of course, at this point,&lt;br />
I&amp;rsquo;m only supporting simple test case reports. I&amp;rsquo;ll expand as I go.&lt;/p></description></item><item><title>Blog: Optimization notes: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</guid><description>
&lt;h2 id="kdtree-and-radius-based-searches">KdTree and radius-based searches&lt;/h2>
&lt;p>After sweeping the existing C++ libraries capable of doing k-nearest neighbor (KNN) search with unsorted radius queries, I have reached the conclusion of using &lt;a href="https://github.com/jlblancoc/nanoflann">nanoflann&lt;/a> as a backend for such searches.&lt;/p>
&lt;p>Their API is nice and easy to use but with one specific caveat: The dynamic &lt;code>KdTree&lt;/code> is not trivial to use. After putting up some unit tests to the KdTree wrapper, I quickly discovered that changing the list of point positions we perform searches against is not fun. My current solution is to hash the current content of the list and check it again on each KNN search!&lt;/p>
&lt;p>If the list of points has been radically changed, the KdTree index will be invalid; so we need to reset it. But, if the list is only being appended to (no changes to old elements), the new points are added to the index.&lt;/p>
&lt;p>At this point, I have mainly three unanswered question:&lt;/p>
&lt;ul>
&lt;li>How efficient is to hash the point list?&lt;/li>
&lt;li>How efficient OpenFOAM&amp;rsquo;s implementation of Jenkins hasher is?&lt;/li>
&lt;li>How efficient is to reset the KdTree index (compared to remove all points and add add the new ones)?&lt;/li>
&lt;/ul></description></item></channel></rss>